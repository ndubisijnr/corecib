{"remainingRequest":"/Users/clark/Desktop/business.corestep.com/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/clark/Desktop/business.corestep.com/node_modules/vue-excel-export/VueComment.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/clark/Desktop/business.corestep.com/node_modules/vue-excel-export/VueComment.vue","mtime":1683675473083},{"path":"/Users/clark/Desktop/business.corestep.com/node_modules/cache-loader/dist/cjs.js","mtime":1670880017776},{"path":"/Users/clark/Desktop/business.corestep.com/node_modules/babel-loader/lib/index.js","mtime":1670880017786},{"path":"/Users/clark/Desktop/business.corestep.com/node_modules/cache-loader/dist/cjs.js","mtime":1670880017776},{"path":"/Users/clark/Desktop/business.corestep.com/node_modules/vue-loader/lib/index.js","mtime":1670880044043}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CiAgICBpbXBvcnQgZG93bmxvYWQgZnJvbSAiYnJvd3Nlci1kb3dubG9hZHMiOwoKICAgIGV4cG9ydCBkZWZhdWx0IHsKICAgICAgICBuYW1lOiAnZXhwb3J0LWV4Y2VsJywKICAgICAgICBwcm9wczogewogICAgICAgICAgICAvLyBtaW1lIHR5cGUgW3hscywgY3N2XQogICAgICAgICAgICB0eXBlOiB7CiAgICAgICAgICAgICAgICB0eXBlOiBTdHJpbmcsCiAgICAgICAgICAgICAgICBkZWZhdWx0OiAieGxzIgogICAgICAgICAgICB9LAogICAgICAgICAgICAvLyBKc29uIHRvIGRvd25sb2FkCiAgICAgICAgICAgIGRhdGE6IHsKICAgICAgICAgICAgICAgIHR5cGU6IEFycmF5LAogICAgICAgICAgICAgICAgcmVxdWlyZWQ6IGZhbHNlLAogICAgICAgICAgICAgICAgZGVmYXVsdDogbnVsbAogICAgICAgICAgICB9LAogICAgICAgICAgICAvLyBmaWVsZHMgaW5zaWRlIHRoZSBKc29uIE9iamVjdCB0aGF0IHlvdSB3YW50IHRvIGV4cG9ydAogICAgICAgICAgICAvLyBpZiBubyBnaXZlbiwgYWxsIHRoZSBwcm9wZXJ0aWVzIGluIHRoZSBKc29uIGFyZSBleHBvcnRlZAogICAgICAgICAgICBmaWVsZHM6IHsKICAgICAgICAgICAgICAgIHR5cGU6IE9iamVjdCwKICAgICAgICAgICAgICAgIHJlcXVpcmVkOiBmYWxzZQogICAgICAgICAgICB9LAogICAgICAgICAgICAvLyB0aGlzIHByb3AgaXMgdXNlZCB0byBmaXggdGhlIHByb2JsZW0gd2l0aCBvdGhlciBjb21wb25lbnRzIHRoYXQgdXNlIHRoZQogICAgICAgICAgICAvLyB2YXJpYWJsZSBmaWVsZHMsIGxpa2UgdmVlLXZhbGlkYXRlLiBleHBvcnRGaWVsZHMgd29ya3MgZXhhY3RseSBsaWtlIGZpZWxkcwogICAgICAgICAgICBleHBvcnRGaWVsZHM6IHsKICAgICAgICAgICAgICAgIHR5cGU6IE9iamVjdCwKICAgICAgICAgICAgICAgIHJlcXVpcmVkOiBmYWxzZQogICAgICAgICAgICB9LAogICAgICAgICAgICAvLyBVc2UgYXMgZmFsbGJhY2sgd2hlbiB0aGUgcm93IGhhcyBubyBmaWVsZCB2YWx1ZXMKICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiB7CiAgICAgICAgICAgICAgICB0eXBlOiBTdHJpbmcsCiAgICAgICAgICAgICAgICByZXF1aXJlZDogZmFsc2UsCiAgICAgICAgICAgICAgICBkZWZhdWx0OiAiIgogICAgICAgICAgICB9LAogICAgICAgICAgICAvLyBUaXRsZShzKSBmb3IgdGhlIGRhdGEsIGNvdWxkIGJlIGEgc3RyaW5nIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MgKG11bHRpcGxlIHRpdGxlcykKICAgICAgICAgICAgdGl0bGU6IHsKICAgICAgICAgICAgICAgIGRlZmF1bHQ6IG51bGwKICAgICAgICAgICAgfSwKICAgICAgICAgICAgLy8gRm9vdGVyKHMpIGZvciB0aGUgZGF0YSwgY291bGQgYmUgYSBzdHJpbmcgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncyAobXVsdGlwbGUgZm9vdGVycykKICAgICAgICAgICAgZm9vdGVyOiB7CiAgICAgICAgICAgICAgICBkZWZhdWx0OiBudWxsCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIC8vIGZpbGVuYW1lIHRvIGV4cG9ydAogICAgICAgICAgICBuYW1lOiB7CiAgICAgICAgICAgICAgICB0eXBlOiBTdHJpbmcsCiAgICAgICAgICAgICAgICBkZWZhdWx0OiAiZGF0YS54bHMiCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIGZldGNoOiB7CiAgICAgICAgICAgICAgICB0eXBlOiBGdW5jdGlvbiwKICAgICAgICAgICAgfSwKICAgICAgICAgICAgbWV0YTogewogICAgICAgICAgICAgICAgdHlwZTogQXJyYXksCiAgICAgICAgICAgICAgICBkZWZhdWx0OiAoKSA9PiBbXQogICAgICAgICAgICB9LAogICAgICAgICAgICB3b3Jrc2hlZXQ6IHsKICAgICAgICAgICAgICAgIHR5cGU6IFN0cmluZywKICAgICAgICAgICAgICAgIGRlZmF1bHQ6ICJTaGVldDEiCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIC8vZXZlbnQgYmVmb3JlIGdlbmVyYXRlIHdhcyBjYWxsZWQKICAgICAgICAgICAgYmVmb3JlR2VuZXJhdGU6IHsKICAgICAgICAgICAgICAgIHR5cGU6IEZ1bmN0aW9uLAogICAgICAgICAgICB9LAogICAgICAgICAgICAvL2V2ZW50IGJlZm9yZSBkb3dubG9hZCBwb3BzIHVwCiAgICAgICAgICAgIGJlZm9yZUZpbmlzaDogewogICAgICAgICAgICAgICAgdHlwZTogRnVuY3Rpb24sCiAgICAgICAgICAgIH0sCiAgICAgICAgfSwKICAgICAgICBjb21wdXRlZDogewogICAgICAgICAgICAvLyB1bmlxdWUgaWRlbnRpZmllcgogICAgICAgICAgICBpZE5hbWUoKSB7CiAgICAgICAgICAgICAgICB2YXIgbm93ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7CiAgICAgICAgICAgICAgICByZXR1cm4gImV4cG9ydF8iICsgbm93OwogICAgICAgICAgICB9LAoKICAgICAgICAgICAgZG93bmxvYWRGaWVsZHMoKSB7CiAgICAgICAgICAgICAgICBpZiAodGhpcy5maWVsZHMgIT09IHVuZGVmaW5lZCkgcmV0dXJuIHRoaXMuZmllbGRzOwoKICAgICAgICAgICAgICAgIGlmICh0aGlzLmV4cG9ydEZpZWxkcyAhPT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcy5leHBvcnRGaWVsZHM7CiAgICAgICAgICAgIH0KICAgICAgICB9LAogICAgICAgIG1ldGhvZHM6IHsKICAgICAgICAgICAgYXN5bmMgZ2VuZXJhdGUoKSB7CiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuYmVmb3JlR2VuZXJhdGUgPT09ICdmdW5jdGlvbicpIHsKICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmJlZm9yZUdlbmVyYXRlKCk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBsZXQgZGF0YSA9IHRoaXMuZGF0YTsKICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5mZXRjaCA9PT0gJ2Z1bmN0aW9uJyB8fCAhZGF0YSkKICAgICAgICAgICAgICAgICAgICBkYXRhID0gYXdhaXQgdGhpcy5mZXRjaCgpOwoKICAgICAgICAgICAgICAgIGlmICghZGF0YSB8fCAhZGF0YS5sZW5ndGgpIHsKICAgICAgICAgICAgICAgICAgICByZXR1cm47CiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgbGV0IGpzb24gPSB0aGlzLmdldFByb2Nlc3NlZEpzb24oZGF0YSwgdGhpcy5kb3dubG9hZEZpZWxkcyk7CiAgICAgICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSAiaHRtbCIpIHsKICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIG1haW5seSBmb3IgdGVzdGluZwogICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmV4cG9ydCgKICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5qc29uVG9YTFMoanNvbiksCiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmFtZS5yZXBsYWNlKCIueGxzIiwgIi5odG1sIiksCiAgICAgICAgICAgICAgICAgICAgICAgICJ0ZXh0L2h0bWwiCiAgICAgICAgICAgICAgICAgICAgKTsKICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy50eXBlID09PSAiY3N2IikgewogICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmV4cG9ydCgKICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5qc29uVG9DU1YoanNvbiksCiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmFtZS5yZXBsYWNlKCIueGxzIiwgIi5jc3YiKSwKICAgICAgICAgICAgICAgICAgICAgICAgImFwcGxpY2F0aW9uL2NzdiIKICAgICAgICAgICAgICAgICAgICApOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXhwb3J0KAogICAgICAgICAgICAgICAgICAgIHRoaXMuanNvblRvWExTKGpzb24pLAogICAgICAgICAgICAgICAgICAgIHRoaXMubmFtZSwKICAgICAgICAgICAgICAgICAgICAiYXBwbGljYXRpb24vdm5kLm1zLWV4Y2VsIgogICAgICAgICAgICAgICAgKTsKICAgICAgICAgICAgfSwKICAgICAgICAgICAgLyoKICAgICAgICAgICAgICAgIFVzZSBkb3dubG9hZGpzIHRvIGdlbmVyYXRlIHRoZSBkb3dubG9hZCBsaW5rCiAgICAgICAgICAgICAgICAqLwogICAgICAgICAgICBleHBvcnQ6IGFzeW5jIGZ1bmN0aW9uIChkYXRhLCBmaWxlbmFtZSwgbWltZSkgewogICAgICAgICAgICAgICAgbGV0IGJsb2IgPSB0aGlzLmJhc2U2NFRvQmxvYihkYXRhLCBtaW1lKTsKICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5iZWZvcmVGaW5pc2ggPT09ICdmdW5jdGlvbicpCiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5iZWZvcmVGaW5pc2goKTsKICAgICAgICAgICAgICAgIGRvd25sb2FkKGJsb2IsIGZpbGVuYW1lLCBtaW1lKTsKICAgICAgICAgICAgfSwKICAgICAgICAgICAgLyoKICAgICAgICAgICAgICAgIGpzb25Ub1hMUwogICAgICAgICAgICAgICAgLS0tLS0tLS0tLS0tLS0tCiAgICAgICAgICAgICAgICBUcmFuc2Zvcm0ganNvbiBkYXRhIGludG8gYW4geG1sIGRvY3VtZW50IHdpdGggTVMgRXhjZWwgZm9ybWF0LCBzYWRseQogICAgICAgICAgICAgICAgaXQgc2hvd3MgYSBwcm9tcHQgd2hlbiBpdCBvcGVucywgdGhhdCBpcyBhIGRlZmF1bHQgYmVoYXZpb3IgZm9yCiAgICAgICAgICAgICAgICBNaWNyb3NvZnQgb2ZmaWNlIGFuZCBjYW5ub3QgYmUgYXZvaWRlZC4gSXQncyByZWNvbW1lbmRlZCB0byB1c2UgQ1NWIGZvcm1hdCBpbnN0ZWFkLgogICAgICAgICAgICAgICAgKi8KICAgICAgICAgICAganNvblRvWExTKGRhdGEpIHsKICAgICAgICAgICAgICAgIGxldCB4bHNUZW1wID0KICAgICAgICAgICAgICAgICAgICAnPGh0bWwgeG1sbnM6bz0idXJuOnNjaGVtYXMtbWljcm9zb2Z0LWNvbTpvZmZpY2U6b2ZmaWNlIiB4bWxuczp4PSJ1cm46c2NoZW1hcy1taWNyb3NvZnQtY29tOm9mZmljZTpleGNlbCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnL1RSL1JFQy1odG1sNDAiPjxoZWFkPjxtZXRhIG5hbWU9UHJvZ0lkIGNvbnRlbnQ9RXhjZWwuU2hlZXQ+IDxtZXRhIG5hbWU9R2VuZXJhdG9yIGNvbnRlbnQ9Ik1pY3Jvc29mdCBFeGNlbCAxMSI+PG1ldGEgaHR0cC1lcXVpdj0iQ29udGVudC1UeXBlIiBjb250ZW50PSJ0ZXh0L2h0bWw7IGNoYXJzZXQ9VVRGLTgiPjwhLS1baWYgZ3RlIG1zbyA5XT48eG1sPjx4OkV4Y2VsV29ya2Jvb2s+PHg6RXhjZWxXb3Jrc2hlZXRzPjx4OkV4Y2VsV29ya3NoZWV0Pjx4Ok5hbWU+JHt3b3Jrc2hlZXR9PC94Ok5hbWU+PHg6V29ya3NoZWV0T3B0aW9ucz48eDpEaXNwbGF5R3JpZGxpbmVzLz48L3g6V29ya3NoZWV0T3B0aW9ucz48L3g6RXhjZWxXb3Jrc2hlZXQ+PC94OkV4Y2VsV29ya3NoZWV0cz48L3g6RXhjZWxXb3JrYm9vaz48L3htbD48IVtlbmRpZl0tLT48c3R5bGU+YnIge21zby1kYXRhLXBsYWNlbWVudDogc2FtZS1jZWxsO308L3N0eWxlPjwvaGVhZD48Ym9keT48dGFibGU+JHt0YWJsZX08L3RhYmxlPjwvYm9keT48L2h0bWw+JzsKICAgICAgICAgICAgICAgIGxldCB4bHNEYXRhID0gIjx0aGVhZD4iOwogICAgICAgICAgICAgICAgY29uc3QgY29sc3BhbiA9IE9iamVjdC5rZXlzKGRhdGFbMF0pLmxlbmd0aDsKICAgICAgICAgICAgICAgIGxldCBfc2VsZiA9IHRoaXM7CgogICAgICAgICAgICAgICAgLy9IZWFkZXIKICAgICAgICAgICAgICAgIGlmICh0aGlzLnRpdGxlICE9IG51bGwpIHsKICAgICAgICAgICAgICAgICAgICB4bHNEYXRhICs9IHRoaXMucGFyc2VFeHRyYURhdGEoCiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGl0bGUsCiAgICAgICAgICAgICAgICAgICAgICAgICc8dHI+PHRoIGNvbHNwYW49IicgKyBjb2xzcGFuICsgJyI+JHtkYXRhfTwvdGg+PC90cj4nCiAgICAgICAgICAgICAgICAgICAgKTsKICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAvL0ZpZWxkcwogICAgICAgICAgICAgICAgeGxzRGF0YSArPSAiPHRyPiI7CiAgICAgICAgICAgICAgICBmb3IgKGxldCBrZXkgaW4gZGF0YVswXSkgewogICAgICAgICAgICAgICAgICAgIHhsc0RhdGEgKz0gIjx0aD4iICsga2V5ICsgIjwvdGg+IjsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHhsc0RhdGEgKz0gIjwvdHI+IjsKICAgICAgICAgICAgICAgIHhsc0RhdGEgKz0gIjwvdGhlYWQ+IjsKCiAgICAgICAgICAgICAgICAvL0RhdGEKICAgICAgICAgICAgICAgIHhsc0RhdGEgKz0gIjx0Ym9keT4iOwogICAgICAgICAgICAgICAgZGF0YS5tYXAoZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7CiAgICAgICAgICAgICAgICAgICAgeGxzRGF0YSArPSAiPHRyPiI7CiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQga2V5IGluIGl0ZW0pIHsKICAgICAgICAgICAgICAgICAgICAgICAgeGxzRGF0YSArPSAiPHRkPiIgKyBfc2VsZi52YWx1ZVJlZm9ybWF0dGVkRm9yTXVsdGlsaW5lcyhpdGVtW2tleV0pICsgIjwvdGQ+IjsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgeGxzRGF0YSArPSAiPC90cj4iOwogICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICB4bHNEYXRhICs9ICI8L3Rib2R5PiI7CgogICAgICAgICAgICAgICAgLy9Gb290ZXIKICAgICAgICAgICAgICAgIGlmICh0aGlzLmZvb3RlciAhPSBudWxsKSB7CiAgICAgICAgICAgICAgICAgICAgeGxzRGF0YSArPSAiPHRmb290PiI7CiAgICAgICAgICAgICAgICAgICAgeGxzRGF0YSArPSB0aGlzLnBhcnNlRXh0cmFEYXRhKAogICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZvb3RlciwKICAgICAgICAgICAgICAgICAgICAgICAgJzx0cj48dGQgY29sc3Bhbj0iJyArIGNvbHNwYW4gKyAnIj4ke2RhdGF9PC90ZD48L3RyPicKICAgICAgICAgICAgICAgICAgICApOwogICAgICAgICAgICAgICAgICAgIHhsc0RhdGEgKz0gIjwvdGZvb3Q+IjsKICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICByZXR1cm4geGxzVGVtcC5yZXBsYWNlKCIke3RhYmxlfSIsIHhsc0RhdGEpLnJlcGxhY2UoIiR7d29ya3NoZWV0fSIsIHRoaXMud29ya3NoZWV0KTsKICAgICAgICAgICAgfSwKICAgICAgICAgICAgLyoKICAgICAgICAgICAgICAgIGpzb25Ub0NTVgogICAgICAgICAgICAgICAgLS0tLS0tLS0tLS0tLS0tCiAgICAgICAgICAgICAgICBUcmFuc2Zvcm0ganNvbiBkYXRhIGludG8gYW4gQ1NWIGZpbGUuCiAgICAgICAgICAgICAgICAqLwogICAgICAgICAgICBqc29uVG9DU1YoZGF0YSkgewogICAgICAgICAgICAgICAgdmFyIGNzdkRhdGEgPSBbXTsKICAgICAgICAgICAgICAgIC8vSGVhZGVyCiAgICAgICAgICAgICAgICBpZiAodGhpcy50aXRsZSAhPSBudWxsKSB7CiAgICAgICAgICAgICAgICAgICAgY3N2RGF0YS5wdXNoKHRoaXMucGFyc2VFeHRyYURhdGEodGhpcy50aXRsZSwgIiR7ZGF0YX1cclxuIikpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgLy9GaWVsZHMKICAgICAgICAgICAgICAgIGZvciAobGV0IGtleSBpbiBkYXRhWzBdKSB7CiAgICAgICAgICAgICAgICAgICAgY3N2RGF0YS5wdXNoKGtleSk7CiAgICAgICAgICAgICAgICAgICAgY3N2RGF0YS5wdXNoKCIsIik7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBjc3ZEYXRhLnBvcCgpOwogICAgICAgICAgICAgICAgY3N2RGF0YS5wdXNoKCJcclxuIik7CiAgICAgICAgICAgICAgICAvL0RhdGEKICAgICAgICAgICAgICAgIGRhdGEubWFwKGZ1bmN0aW9uIChpdGVtKSB7CiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQga2V5IGluIGl0ZW0pIHsKICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGVzY2FwZWRDU1YgPSAnPVwiJyArIGl0ZW1ba2V5XSArICdcIic7IC8vIGNhc3QgTnVtYmVycyB0byBzdHJpbmcKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVzY2FwZWRDU1YubWF0Y2goL1ssIlxuXS8pKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlc2NhcGVkQ1NWID0gJyInICsgZXNjYXBlZENTVi5yZXBsYWNlKC9cIi9nLCAnIiInKSArICciJzsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICBjc3ZEYXRhLnB1c2goZXNjYXBlZENTVik7CiAgICAgICAgICAgICAgICAgICAgICAgIGNzdkRhdGEucHVzaCgiLCIpOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBjc3ZEYXRhLnBvcCgpOwogICAgICAgICAgICAgICAgICAgIGNzdkRhdGEucHVzaCgiXHJcbiIpOwogICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICAvL0Zvb3RlcgogICAgICAgICAgICAgICAgaWYgKHRoaXMuZm9vdGVyICE9IG51bGwpIHsKICAgICAgICAgICAgICAgICAgICBjc3ZEYXRhLnB1c2godGhpcy5wYXJzZUV4dHJhRGF0YSh0aGlzLmZvb3RlciwgIiR7ZGF0YX1cclxuIikpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgcmV0dXJuIGNzdkRhdGEuam9pbigiIik7CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIC8qCiAgICAgICAgICAgICAgICBnZXRQcm9jZXNzZWRKc29uCiAgICAgICAgICAgICAgICAtLS0tLS0tLS0tLS0tLS0KICAgICAgICAgICAgICAgIEdldCBvbmx5IHRoZSBkYXRhIHRvIGV4cG9ydCwgaWYgbm8gZmllbGRzIGFyZSBzZXQgcmV0dXJuIGFsbCB0aGUgZGF0YQogICAgICAgICAgICAgICAgKi8KICAgICAgICAgICAgZ2V0UHJvY2Vzc2VkSnNvbihkYXRhLCBoZWFkZXIpIHsKICAgICAgICAgICAgICAgIGxldCBrZXlzID0gdGhpcy5nZXRLZXlzKGRhdGEsIGhlYWRlcik7CiAgICAgICAgICAgICAgICBsZXQgbmV3RGF0YSA9IFtdOwogICAgICAgICAgICAgICAgbGV0IF9zZWxmID0gdGhpczsKICAgICAgICAgICAgICAgIGRhdGEubWFwKGZ1bmN0aW9uIChpdGVtLCBpbmRleCkgewogICAgICAgICAgICAgICAgICAgIGxldCBuZXdJdGVtID0ge307CiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgbGFiZWwgaW4ga2V5cykgewogICAgICAgICAgICAgICAgICAgICAgICBsZXQgcHJvcGVydHkgPSBrZXlzW2xhYmVsXTsKICAgICAgICAgICAgICAgICAgICAgICAgbmV3SXRlbVtsYWJlbF0gPSBfc2VsZi5nZXRWYWx1ZShwcm9wZXJ0eSwgaXRlbSk7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIG5ld0RhdGEucHVzaChuZXdJdGVtKTsKICAgICAgICAgICAgICAgIH0pOwoKICAgICAgICAgICAgICAgIHJldHVybiBuZXdEYXRhOwogICAgICAgICAgICB9LAogICAgICAgICAgICBnZXRLZXlzKGRhdGEsIGhlYWRlcikgewogICAgICAgICAgICAgICAgaWYgKGhlYWRlcikgewogICAgICAgICAgICAgICAgICAgIHJldHVybiBoZWFkZXI7CiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgbGV0IGtleXMgPSB7fTsKICAgICAgICAgICAgICAgIGZvciAobGV0IGtleSBpbiBkYXRhWzBdKSB7CiAgICAgICAgICAgICAgICAgICAga2V5c1trZXldID0ga2V5OwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgcmV0dXJuIGtleXM7CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIC8qCiAgICAgICAgICAgICAgICBwYXJzZUV4dHJhRGF0YQogICAgICAgICAgICAgICAgLS0tLS0tLS0tLS0tLS0tCiAgICAgICAgICAgICAgICBQYXJzZSB0aXRsZSBhbmQgZm9vdGVyIGF0dHJpYnV0ZSB0byB0aGUgY3N2IGZvcm1hdAogICAgICAgICAgICAgICAgKi8KICAgICAgICAgICAgcGFyc2VFeHRyYURhdGEoZXh0cmFEYXRhLCBmb3JtYXQpIHsKICAgICAgICAgICAgICAgIGxldCBwYXJzZURhdGEgPSAiIjsKICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGV4dHJhRGF0YSkpIHsKICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4dHJhRGF0YS5sZW5ndGg7IGkrKykgewogICAgICAgICAgICAgICAgICAgICAgICBwYXJzZURhdGEgKz0gZm9ybWF0LnJlcGxhY2UoIiR7ZGF0YX0iLCBleHRyYURhdGFbaV0pOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgcGFyc2VEYXRhICs9IGZvcm1hdC5yZXBsYWNlKCIke2RhdGF9IiwgZXh0cmFEYXRhKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZURhdGE7CiAgICAgICAgICAgIH0sCgogICAgICAgICAgICBnZXRWYWx1ZShrZXksIGl0ZW0pIHsKICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gdHlwZW9mIGtleSAhPT0gIm9iamVjdCIgPyBrZXkgOiBrZXkuZmllbGQ7CiAgICAgICAgICAgICAgICBsZXQgaW5kZXhlcyA9IHR5cGVvZiBmaWVsZCAhPT0gInN0cmluZyIgPyBbXSA6IGZpZWxkLnNwbGl0KCIuIik7CiAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLmRlZmF1bHRWYWx1ZTsKCiAgICAgICAgICAgICAgICBpZiAoIWZpZWxkKQogICAgICAgICAgICAgICAgICAgIHZhbHVlID0gaXRlbTsKICAgICAgICAgICAgICAgIGVsc2UgaWYgKGluZGV4ZXMubGVuZ3RoID4gMSkKICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWVGcm9tTmVzdGVkSXRlbShpdGVtLCBpbmRleGVzKTsKICAgICAgICAgICAgICAgIGVsc2UKICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMucGFyc2VWYWx1ZShpdGVtW2ZpZWxkXSk7CgogICAgICAgICAgICAgICAgaWYgKGtleS5oYXNPd25Qcm9wZXJ0eSgnY2FsbGJhY2snKSkKICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWVGcm9tQ2FsbGJhY2sodmFsdWUsIGtleS5jYWxsYmFjayk7CgogICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlOwogICAgICAgICAgICB9LAoKICAgICAgICAgICAgLyoKICAgICAgICAgICAgY29udmVydCB2YWx1ZXMgd2l0aCBuZXdsaW5lIFxuIGNoYXJhY3RlcnMgaW50byA8YnIvPgogICAgICAgICAgICAqLwogICAgICAgICAgICB2YWx1ZVJlZm9ybWF0dGVkRm9yTXVsdGlsaW5lcyh2YWx1ZSkgewogICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09ICJzdHJpbmciKSByZXR1cm4gKHZhbHVlLnJlcGxhY2UoL1xuL2lnLCAiPGJyLz4iKSk7CiAgICAgICAgICAgICAgICBlbHNlIHJldHVybiAodmFsdWUpOwogICAgICAgICAgICB9LAoKICAgICAgICAgICAgZ2V0VmFsdWVGcm9tTmVzdGVkSXRlbShpdGVtLCBpbmRleGVzKSB7CiAgICAgICAgICAgICAgICBsZXQgbmVzdGVkSXRlbSA9IGl0ZW07CiAgICAgICAgICAgICAgICBmb3IgKGxldCBpbmRleCBvZiBpbmRleGVzKSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKG5lc3RlZEl0ZW0pCiAgICAgICAgICAgICAgICAgICAgICAgIG5lc3RlZEl0ZW0gPSBuZXN0ZWRJdGVtW2luZGV4XTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlVmFsdWUobmVzdGVkSXRlbSk7CiAgICAgICAgICAgIH0sCgogICAgICAgICAgICBnZXRWYWx1ZUZyb21DYWxsYmFjayhpdGVtLCBjYWxsYmFjaykgewogICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gImZ1bmN0aW9uIikKICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWZhdWx0VmFsdWUKICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gY2FsbGJhY2soaXRlbSk7CiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVZhbHVlKHZhbHVlKTsKICAgICAgICAgICAgfSwKICAgICAgICAgICAgcGFyc2VWYWx1ZSh2YWx1ZSkgewogICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlIHx8IHZhbHVlID09PSAwIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nCiAgICAgICAgICAgICAgICAgICAgPyB2YWx1ZQogICAgICAgICAgICAgICAgICAgIDogdGhpcy5kZWZhdWx0VmFsdWU7CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIGJhc2U2NFRvQmxvYihkYXRhLCBtaW1lKSB7CiAgICAgICAgICAgICAgICBsZXQgYmFzZTY0ID0gd2luZG93LmJ0b2Eod2luZG93LnVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChkYXRhKSkpOwogICAgICAgICAgICAgICAgbGV0IGJzdHIgPSBhdG9iKGJhc2U2NCk7CiAgICAgICAgICAgICAgICBsZXQgbiA9IGJzdHIubGVuZ3RoOwogICAgICAgICAgICAgICAgbGV0IHU4YXJyID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KG4pOwogICAgICAgICAgICAgICAgd2hpbGUgKG4tLSkgewogICAgICAgICAgICAgICAgICAgIHU4YXJyW25dID0gYnN0ci5jaGFyQ29kZUF0KG4pOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCbG9iKFt1OGFycl0sIHt0eXBlOiBtaW1lfSk7CiAgICAgICAgICAgIH0KICAgICAgICB9IC8vIGVuZCBtZXRob2RzCiAgICB9Owo="},{"version":3,"sources":["VueComment.vue"],"names":[],"mappings":";AAWA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"VueComment.vue","sourceRoot":"node_modules/vue-excel-export","sourcesContent":["<template>\n    <div\n            :id=\"idName\"\n            @click=\"generate\">\n        <slot>\n            Download {{name}}\n        </slot>\n    </div>\n</template>\n\n<script>\n    import download from \"browser-downloads\";\n\n    export default {\n        name: 'export-excel',\n        props: {\n            // mime type [xls, csv]\n            type: {\n                type: String,\n                default: \"xls\"\n            },\n            // Json to download\n            data: {\n                type: Array,\n                required: false,\n                default: null\n            },\n            // fields inside the Json Object that you want to export\n            // if no given, all the properties in the Json are exported\n            fields: {\n                type: Object,\n                required: false\n            },\n            // this prop is used to fix the problem with other components that use the\n            // variable fields, like vee-validate. exportFields works exactly like fields\n            exportFields: {\n                type: Object,\n                required: false\n            },\n            // Use as fallback when the row has no field values\n            defaultValue: {\n                type: String,\n                required: false,\n                default: \"\"\n            },\n            // Title(s) for the data, could be a string or an array of strings (multiple titles)\n            title: {\n                default: null\n            },\n            // Footer(s) for the data, could be a string or an array of strings (multiple footers)\n            footer: {\n                default: null\n            },\n            // filename to export\n            name: {\n                type: String,\n                default: \"data.xls\"\n            },\n            fetch: {\n                type: Function,\n            },\n            meta: {\n                type: Array,\n                default: () => []\n            },\n            worksheet: {\n                type: String,\n                default: \"Sheet1\"\n            },\n            //event before generate was called\n            beforeGenerate: {\n                type: Function,\n            },\n            //event before download pops up\n            beforeFinish: {\n                type: Function,\n            },\n        },\n        computed: {\n            // unique identifier\n            idName() {\n                var now = new Date().getTime();\n                return \"export_\" + now;\n            },\n\n            downloadFields() {\n                if (this.fields !== undefined) return this.fields;\n\n                if (this.exportFields !== undefined) return this.exportFields;\n            }\n        },\n        methods: {\n            async generate() {\n                if (typeof this.beforeGenerate === 'function') {\n                    await this.beforeGenerate();\n                }\n                let data = this.data;\n                if (typeof this.fetch === 'function' || !data)\n                    data = await this.fetch();\n\n                if (!data || !data.length) {\n                    return;\n                }\n\n                let json = this.getProcessedJson(data, this.downloadFields);\n                if (this.type === \"html\") {\n                    // this is mainly for testing\n                    return this.export(\n                        this.jsonToXLS(json),\n                        this.name.replace(\".xls\", \".html\"),\n                        \"text/html\"\n                    );\n                } else if (this.type === \"csv\") {\n                    return this.export(\n                        this.jsonToCSV(json),\n                        this.name.replace(\".xls\", \".csv\"),\n                        \"application/csv\"\n                    );\n                }\n                return this.export(\n                    this.jsonToXLS(json),\n                    this.name,\n                    \"application/vnd.ms-excel\"\n                );\n            },\n            /*\n                Use downloadjs to generate the download link\n                */\n            export: async function (data, filename, mime) {\n                let blob = this.base64ToBlob(data, mime);\n                if (typeof this.beforeFinish === 'function')\n                    await this.beforeFinish();\n                download(blob, filename, mime);\n            },\n            /*\n                jsonToXLS\n                ---------------\n                Transform json data into an xml document with MS Excel format, sadly\n                it shows a prompt when it opens, that is a default behavior for\n                Microsoft office and cannot be avoided. It's recommended to use CSV format instead.\n                */\n            jsonToXLS(data) {\n                let xlsTemp =\n                    '<html xmlns:o=\"urn:schemas-microsoft-com:office:office\" xmlns:x=\"urn:schemas-microsoft-com:office:excel\" xmlns=\"http://www.w3.org/TR/REC-html40\"><head><meta name=ProgId content=Excel.Sheet> <meta name=Generator content=\"Microsoft Excel 11\"><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"><!--[if gte mso 9]><xml><x:ExcelWorkbook><x:ExcelWorksheets><x:ExcelWorksheet><x:Name>${worksheet}</x:Name><x:WorksheetOptions><x:DisplayGridlines/></x:WorksheetOptions></x:ExcelWorksheet></x:ExcelWorksheets></x:ExcelWorkbook></xml><![endif]--><style>br {mso-data-placement: same-cell;}</style></head><body><table>${table}</table></body></html>';\n                let xlsData = \"<thead>\";\n                const colspan = Object.keys(data[0]).length;\n                let _self = this;\n\n                //Header\n                if (this.title != null) {\n                    xlsData += this.parseExtraData(\n                        this.title,\n                        '<tr><th colspan=\"' + colspan + '\">${data}</th></tr>'\n                    );\n                }\n\n                //Fields\n                xlsData += \"<tr>\";\n                for (let key in data[0]) {\n                    xlsData += \"<th>\" + key + \"</th>\";\n                }\n                xlsData += \"</tr>\";\n                xlsData += \"</thead>\";\n\n                //Data\n                xlsData += \"<tbody>\";\n                data.map(function (item, index) {\n                    xlsData += \"<tr>\";\n                    for (let key in item) {\n                        xlsData += \"<td>\" + _self.valueReformattedForMultilines(item[key]) + \"</td>\";\n                    }\n                    xlsData += \"</tr>\";\n                });\n                xlsData += \"</tbody>\";\n\n                //Footer\n                if (this.footer != null) {\n                    xlsData += \"<tfoot>\";\n                    xlsData += this.parseExtraData(\n                        this.footer,\n                        '<tr><td colspan=\"' + colspan + '\">${data}</td></tr>'\n                    );\n                    xlsData += \"</tfoot>\";\n                }\n\n                return xlsTemp.replace(\"${table}\", xlsData).replace(\"${worksheet}\", this.worksheet);\n            },\n            /*\n                jsonToCSV\n                ---------------\n                Transform json data into an CSV file.\n                */\n            jsonToCSV(data) {\n                var csvData = [];\n                //Header\n                if (this.title != null) {\n                    csvData.push(this.parseExtraData(this.title, \"${data}\\r\\n\"));\n                }\n                //Fields\n                for (let key in data[0]) {\n                    csvData.push(key);\n                    csvData.push(\",\");\n                }\n                csvData.pop();\n                csvData.push(\"\\r\\n\");\n                //Data\n                data.map(function (item) {\n                    for (let key in item) {\n                        let escapedCSV = '=\\\"' + item[key] + '\\\"'; // cast Numbers to string\n                        if (escapedCSV.match(/[,\"\\n]/)) {\n                            escapedCSV = '\"' + escapedCSV.replace(/\\\"/g, '\"\"') + '\"';\n                        }\n                        csvData.push(escapedCSV);\n                        csvData.push(\",\");\n                    }\n                    csvData.pop();\n                    csvData.push(\"\\r\\n\");\n                });\n                //Footer\n                if (this.footer != null) {\n                    csvData.push(this.parseExtraData(this.footer, \"${data}\\r\\n\"));\n                }\n                return csvData.join(\"\");\n            },\n            /*\n                getProcessedJson\n                ---------------\n                Get only the data to export, if no fields are set return all the data\n                */\n            getProcessedJson(data, header) {\n                let keys = this.getKeys(data, header);\n                let newData = [];\n                let _self = this;\n                data.map(function (item, index) {\n                    let newItem = {};\n                    for (let label in keys) {\n                        let property = keys[label];\n                        newItem[label] = _self.getValue(property, item);\n                    }\n                    newData.push(newItem);\n                });\n\n                return newData;\n            },\n            getKeys(data, header) {\n                if (header) {\n                    return header;\n                }\n\n                let keys = {};\n                for (let key in data[0]) {\n                    keys[key] = key;\n                }\n                return keys;\n            },\n            /*\n                parseExtraData\n                ---------------\n                Parse title and footer attribute to the csv format\n                */\n            parseExtraData(extraData, format) {\n                let parseData = \"\";\n                if (Array.isArray(extraData)) {\n                    for (var i = 0; i < extraData.length; i++) {\n                        parseData += format.replace(\"${data}\", extraData[i]);\n                    }\n                } else {\n                    parseData += format.replace(\"${data}\", extraData);\n                }\n                return parseData;\n            },\n\n            getValue(key, item) {\n                const field = typeof key !== \"object\" ? key : key.field;\n                let indexes = typeof field !== \"string\" ? [] : field.split(\".\");\n                let value = this.defaultValue;\n\n                if (!field)\n                    value = item;\n                else if (indexes.length > 1)\n                    value = this.getValueFromNestedItem(item, indexes);\n                else\n                    value = this.parseValue(item[field]);\n\n                if (key.hasOwnProperty('callback'))\n                    value = this.getValueFromCallback(value, key.callback);\n\n                return value;\n            },\n\n            /*\n            convert values with newline \\n characters into <br/>\n            */\n            valueReformattedForMultilines(value) {\n                if (typeof (value) == \"string\") return (value.replace(/\\n/ig, \"<br/>\"));\n                else return (value);\n            },\n\n            getValueFromNestedItem(item, indexes) {\n                let nestedItem = item;\n                for (let index of indexes) {\n                    if (nestedItem)\n                        nestedItem = nestedItem[index];\n                }\n                return this.parseValue(nestedItem);\n            },\n\n            getValueFromCallback(item, callback) {\n                if (typeof callback !== \"function\")\n                    return this.defaultValue\n                const value = callback(item);\n                return this.parseValue(value);\n            },\n            parseValue(value) {\n                return value || value === 0 || typeof value === 'boolean'\n                    ? value\n                    : this.defaultValue;\n            },\n            base64ToBlob(data, mime) {\n                let base64 = window.btoa(window.unescape(encodeURIComponent(data)));\n                let bstr = atob(base64);\n                let n = bstr.length;\n                let u8arr = new Uint8ClampedArray(n);\n                while (n--) {\n                    u8arr[n] = bstr.charCodeAt(n);\n                }\n                return new Blob([u8arr], {type: mime});\n            }\n        } // end methods\n    };\n</script>\n"]}]}